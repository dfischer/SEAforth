( $Id: route.mf,v 1.3.4.2 2006-08-25 23:40:31 randy Exp $ ) 
\ routing is used to move code and data between nodes

\ routing uses 27 rom words, 3 return-stack locations, and 4 data-stack locations
\ it requires the 'neighborhood' words  wake  and  na>a
\ the flag shown below is non-zero on router nodes, zero on the deliver node

decimal
machine-forth
: open-route ( rd -- f ) \ set local A reg and wake next node
   a! a@ 2/
   2/ 2/ if        \ router node       \ slot2 ok at x0-x2, x7-xa, xf
     a@ ....
     push @p+ pop .    @p+ open-route     \ DS: f rd inst ....  A: nsew
     !a !a !a ;        ( remaining route descriptor)
   then            \ deliver node
   a@ na>a -;        ( +7)

: send-msg ( f n -- f ) \ pass message from source to destination
   pop over push
   push over if    \ router node       \ slot2 ok at x7, xf
     drop @p+ !a .     @p+ send-msg
                       ( message-count - 1)
     !a @p+ !a ;       begin @p+ . !a+ unext
   then            \ deliver node wakes up destination
   drop drop @p+ dup   . . . .
   !a !a ;         ( +9)

: recv-msg ( f n -- f ) \ pass message from destination to source
   pop over push
   push over if    \ router node       \ slot2 ok at x6, xe
     drop @p+ !a .     @p+ recv-msg
                       ( message-count - 1)
     !a @p+ !a ;       begin @a+ . !p+ unext
   then            \ deliver node
   drop drop ;       ( +7)

[ 0 ] [if]
: pause-route ( f -- f )
   a@ over if      \ router node       \ slot2 ok at x0-x4, x7-xc, xf
     @p+ !a . .        pause-route
   then
   @b pause        \ router or deliver node
   drop a! ;         ( +5)
[then]

: close-route ( f -- ) \ release next node
   if              \ router node
     @p+ !a drop ;   close-route -; 
   then
   drop ;            ( +4)

[ 0 ] [if] \ preliminary documentation; could probably use lots more examples

   Routing is meant to be used sparingly, between widely spaced nodes or to/from
 off-chip resources, to move blocks of code or 'data. Routing should not use nodes
 that are performing time-critical operations.

   A route is opened from a source router node, through other router nodes, and
 ends in a deliver node, which has a port that connects to a desination node.

   The route descriptor is a sequence of up to eight NORTH, SOUTH, EAST, or WEST
 tokens which describes the directions (ports) used by each of the routing nodes,
 from the source node through the deliver node, to link the source node to the
 destination node. Note that only n - 1 descriptors are needed to link n nodes.

   The process of opening a route proceeds from the source node to the deliver
 node along the path specified by the route descriptor, sleeping at each node
 until the next responds to its wake-up request. Note that the destination node
 is not part of the route, and is not affected by the process. Once a route is
 opened, all its nodes sleep awaiting message transfers or closure.

   While a route is open, multiple send-msg and recv-msg messages may be passed
 between the source and destination nodes before the route is closed. The
 destination node is only involved during the message 'data transfer, and may be
 running or asleep between messages.

   An 'imposed' message is not expected by the destination node, which may be
 asleep on multiple ports and doesn't know the message count. It must be a
 send-msg containing only code starting with the standard '. . . .' wake-up.

   A 'requested' message is one that the destination node is expecting, so it
 sleeps on a single port and knows the number of 'data words being transferred.
 Requested messages may consist of 'data or code and be sent in either direction.

   An initial imposed message may be followed by requested messages if its
 contents prepare the destination node for them.


sequence generated by open-route
  on router nodes                      on deliver node

   (1)  . . . .
   (2)  @p+ open-route                   -none-
   (3)  [route descriptor]

sequence generated by send-msg
  on router nodes                      on deliver node

   (1)  @p+ send-msg                     (#)  --message-count words sent--
   (2)  [message-count - 1]
   (3)  begin @p+ . !a+ unext
   (#)  --message-count words sent--

sequence generated by recv-msg
  on router nodes                      on deliver node

   (1)  @p+ recv-msg                     (#)  --message-count words received--
   (2)  [message-count - 1]
   (3)  begin @a+ . !p+ unext
   (#)  --message-count words received--

sequence generated by close-route
  on router nodes                      on deliver node

   (1)  close-route -;                   -none-


examples of possible usage

   (a) no wrappers, imposed code execution (count only in forthlet, wakeup required)
       (1) destination node may be in multi-port sleep or checking ports via pause
       (2) forthlet runs on node0 to send code while destination node executes it
       (3) when transfer complete, destination node returns via ';' in message

   (b) no wrappers, requested code execution (count only in forthlet, no wakeup)
       (1) destination (or other) node sends x0 message to ram server,
           then calls port, sleeping until code arrives
       (2) forthlet runs on node0 to send code while destination node executes it
       (3) when transfer complete, destination node returns via ';' in message

   (c) no wrappers, requested 'data (requires same count in forthlet as in loop)
       (1) destination (or other) node sends x0 message to ram server,
           then enters loop to read/write port 'data, sleeping until it arrives
       (2) forthlet runs on node0 to send/receive 'data while destination node
           reads/writes it
       (3) when transfer complete, destination node continues processing

   (d)


example send-msg message contents (with wrapper)

   (a) an imposed store message (message-count = body-count + 7)

       (1)  . . . .
       (2)  @p+ a!
       (3)  [destination address]
       (4)  @p+ push
       (5)  [body-count - 1]
       (6)  begin @p+ . !a+ unext
       (#)  --body-count words--
       (7)  ;

   (b) an imposed store-and-execute message (message-count = body-count + 7)

       (1)  . . . .
       (2)  @p+ a!
       (3)  [destination address]
       (4)  @p+ push
       (5)  [body-count - 1]
       (6)  begin @p+ . !a+ unext
       (#)  --body-count words--
       (7)  start-word -;

   (c)

[then]

[ 0 ] [if] \ old version

\ uses 26 rom words, 5 'data stack, and 5 return stack locations

$083 org

  19 +fwd ;:
  20 +fwd ;:push
  21 +fwd pass-n

\ must be at x3, xd for slot2 branches to reach
: route ( rd -- )                      \ called from port or ram/rom  ( R+=5, S+=5)
   dup [ 3 ]# and
   push 2/ 2/ [ $100 ]#
   begin 2/ . . unext
   [ $155 ]# xor a! dup
   @p+ push . .        . . . .      ( 1)
   2/ if \ else toport ( +10)

: tonode ( rd x)                       \ transmit message to a router node's port
     pop !a drop @p+   @p+ route    ( 2)
     !a !a ;:          ( descriptor ( 3) ( +3)  \ slot2 ok at x7, xf

: pass ( n)                            \ called by coroutine that sends the data
     pop pass-n
: pass-; ( )
     @p+ !a ;          ;            ( 7)  ( +3)

   then
: toport ( x x)                        \ deliver message to the dest node's port
   drop drop pop dup   ( . . . . ) ( 1,2)
   !a !a ;:             ( +2)          \ slot2 ok at x0-x5, x7-xd, xf

: deliver ( n)
   pop over ;:push -;   ( +1)          \ slot2 ok at x0-x5, x7-xd, xf

\ must be at x1-x7, x9-xf for slot2 branches to reach
: ;:                                   \ coroutine call
   pop pop over         ( +1)
: ;:push ( iji)
   push push drop ;     ( +1)

: pass-n ( n rtn)
     over push push .
     @p+ !a !a .       @p+ ;:                ( 4)
                       ( count )             ( 5)
     @p+ !a ;          begin @p+ . !a+ unext ( 6) ( +5)

[then]
[